<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Routing | Sisk Framework </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Routing | Sisk Framework ">
      
      
      <link rel="icon" href="../../assets/img/favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/fundamentals/routing.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

      <!-- Cloudflare Web Analytics -->
      <script defer="" src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "e1483f9ff9e246f4bd69e45a87ef6923"}'></script>
      <!-- End Cloudflare Web Analytics -->

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../assets/img/Icon.png" alt="Sisk Framework">
            Sisk Framework
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="routing">Routing</h1>

<p>The router refers to what redirects requests to their proper places. A <a href="/api/Sisk.Core.Routing.Router">Router</a> is responsible for routing <a href="/api/Sisk.Core.Routing.Route">Route</a> to its responsible controllers, methods or callbacks. What the Router uses to match a route with a Route is the request path and its method. These two items are responsible for assigning a request to a route.</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/hey/&lt;name&gt;&quot;, (request) =&gt;
{
    var name = request.Query[&quot;name&quot;].GetString();
    return new HttpResponse() { Content = new StringContent(&quot;Hello, &quot; + name) };
});

// alternative way using the + operator
mainRouter += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    return new HttpResponse()
        .WithContent(&quot;Hello, world!&quot;);
});
</code></pre>
<p>To understand what a route is capable of doing, we need to understand what a request is capable of doing. An <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> will contain everything you need. Sisk also includes some extra features that speed up the overral development.</p>
<h2 id="matching-routes">Matching routes</h2>
<p>When a request is received by the HTTP server, Sisk searches for a route that satisfies the expression of the path received by the request. The expression is always tested between the route and the request path, without considering the query string.</p>
<p>This test does not have priority and is exclusive to a single route. When no route is tested with that request, the <a href="/api/Sisk.Core.Routing.Router.NotFoundErrorHandler">Router.NotFoundErrorHandler</a> response is returned to the client. When a path is tested but no method is tested for that request, the <a href="/api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler">Router.MethodNotAllowedErrorHandler</a> response is sent back to the client.</p>
<p>Sisk checks for the possibility of route collisions to avoid these problems. When defining routes, Sisk will look for possible routes that might collide with the route being defined. This test includes checking the path and the method that the route is set to accept.</p>
<h3 id="creating-routes-using-paths">Creating routes using paths</h3>
<p>You can define routes using various <code>SetRoute</code> methods.</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/hey/&lt;name&gt;&quot;, (request) =&gt;
{
    string name = request.Query[&quot;name&quot;]!; // name will never be null in this context
    return request.CreateOkResponse($&quot;Hello, {name}&quot;);
});

// or multiple parameters
mainRouter.SetRoute(RouteMethod.Get, &quot;/hey/&lt;name&gt;/surname/&lt;surname&gt;&quot;, (request) =&gt;
{
    string name = request.Query[&quot;name&quot;]!;
    string surname = request.Query[&quot;surname&quot;]!;
    return request.CreateOkResponse($&quot;Hello, {name} {surname}!&quot;);
});
</code></pre>
<p>The HTTP request <a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a> property also stores the content of an original query, but if there are parameters in the route with the same name as a query, it will be replaced by what is in the route. The path that is matched with an request URI is always the path as explained in <a href="https://www.rfc-editor.org/rfc/rfc3986#section-3.3">RFC 3986</a>.</p>
<p>You can also get an query parameter, including an route parameter, casting it to the desired type, with <a href="/api/Sisk.Core.Http.HttpRequest.GetQueryValue">GetQueryValue</a>:</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/user/&lt;id&gt;&quot;, (request) =&gt;
{
    Guid id = request.GetQueryValue&lt;Guid&gt;(&quot;id&quot;);
});
</code></pre>
<p>Internally, the implementation of this method differs from .NET 6 to newer versions of .NET that did not yet implement <code>IParsable</code>, so to make it compatible, some converters were implemented manually. You can see the <a href="https://github.com/sisk-http/core/blob/main/src/Internal/Parseable.cs">supported types here</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Paths have their trailing <code>/</code> ignored in both request and route path, that is, if you try to access a route defined as <code>/index/page</code> you'll be able to access using <code>/index/page/</code> too.</p>
<p>You can also force URLs to terminate with <code>/</code> enabling the <a href="/api/Sisk.Core.Http.HttpServerFlags.ForceTrailingSlash">ForceTrailingSlash</a> flag.</p>
</div>
<h3 id="creating-routes-using-class-instances">Creating routes using class instances</h3>
<p>You can also define routes dynamically using reflection with the attribute <a href="/api/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a>. This way, the instance of a class in which its methods implement this attribute will have their routes defined in the target router.</p>
<p>Methods marked with the route attribute must be static.</p>
<pre><code class="lang-cs">public class MyController
{
    // will be reached as an instance form
    [Route(RouteMethod.Get, &quot;/&quot;)]
    HttpResponse Index(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        res.Content = new StringContent(&quot;Index!&quot;);
        return res;
    }

    // static methods only be reached when setting the object type
    [Route(RouteMethod.Get, &quot;/hello&quot;)]
    static HttpResponse Hello(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        res.Content = new StringContent(&quot;Hello world!&quot;);
        return res;
    }
}
</code></pre>
<p>Each route method (with the exception of Any) also contains its own attribute, such as:</p>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    HttpResponse Index(HttpRequest request)
    {
        return new HttpResponse()
            .WithContent(new HtmlContent(&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;));
    }
}
</code></pre>
<p>Then you can define the routes of the MyController instance:</p>
<pre><code class="lang-cs">var myController = new MyController();
mainRouter.SetObject(myController);
</code></pre>
<p>Alternatively, you can define your members statically, without an instance, by passing the class's type as a parameter:</p>
<pre><code class="lang-cs">mainRouter.SetObject(typeof(MyController));
</code></pre>
<p>The diferences between <code>SetObject(object)</code> and <code>SetObject(type)</code> is the way the router searchs for route methods. The first searches all instance methods of the object. Functions will be called on a singleton of the parameter object. The second one searchs for static methods, public or not. Both methods searchs for private and public methods through reflection.</p>
<p>Since Sisk version 0.16, it is possible to enable AutoScan, which will search for user-defined classes that implement <code>RouterModule</code> and will automatically associate it with the router. This method is experimental and is not supported with AOT compilation.</p>
<pre><code class="lang-cs">mainRouter.AutoScanModules&lt;ApiController&gt;();
</code></pre>
<p>The above instruction will search for all types which implements <code>ApiController</code> but not the type itself. The two optional parameters indicate how the method will search for these types. The first argument implies the Assembly where the types will be searched and the second indicates the way in which the types will be instantiated, whether by instance activation or by searching for static methods.</p>
<h2 id="regex-routes">Regex routes</h2>
<p>Instead of using the default HTTP path matching methods, you can mark a route to be interpreted with Regex.</p>
<pre><code class="lang-cs">Route indexRoute = new Route(RouteMethod.Get, @&quot;\/[a-z]+\/&quot;, &quot;My route&quot;, IndexPage, null);
indexRoute.UseRegex = true;
mainRouter.SetRoute(indexRoute);
</code></pre>
<p>Or with <a href="/api/Sisk.Core.Routing.RegexRoute">RegexRoute</a> class:</p>
<pre><code class="lang-cs">RegexRoute indexRoute = new RegexRoute(RouteMethod.Get, @&quot;\/[a-z]+\/&quot;, request =&gt;
{
    return new HttpResponse(&quot;hello, world&quot;);
});
mainRouter.SetRoute(indexRoute);
</code></pre>
<p>You can also capture groups from the regex pattern into the <a href="/api/Sisk.Core.Http.HttpRequest.Query">Request.Query</a> contents:</p>
<pre><code class="lang-cs">[RegexRoute(RouteMethod.Get, @&quot;/uploads/(?&lt;filename&gt;.*\.(jpeg|jpg|png))&quot;)]
static HttpResponse RegexRoute(HttpRequest request)
{
    string filename = request.Query[&quot;filename&quot;].GetString();
    return new HttpResponse().WithContent($&quot;Acessing file {filename}&quot;);
}
</code></pre>
<h2 id="any-method-routes">Any method routes</h2>
<p>You can define a route to be matched only by its path and skip the HTTP method. This can be useful for you to do method validation inside the route callback.</p>
<pre><code class="lang-cs">// will match / on any HTTP method
mainRouter.SetRoute(RouteMethod.Any, &quot;/&quot;, callbackFunction);
</code></pre>
<h2 id="any-path-routes">Any path routes</h2>
<p>Any path routes test for any path received by the HTTP server, subject to the route method being tested. If the route method is RouteMethod.Any and the route uses <a href="/api/Sisk.Core.Routing.Route.AnyPath">Route.AnyPath</a> in its path expression, this route will listen to all requests from the HTTP server, and no other routes can be defined.</p>
<pre><code class="lang-cs">// the following route will match all POST requests
mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction);
</code></pre>
<h2 id="ignore-case-route-matching">Ignore case route matching</h2>
<p>By default, the interpretation of routes with requests are case-sensitive. To make it ignore case, enable this option:</p>
<pre><code class="lang-cs">mainRouter.MatchRoutesIgnoreCase = true;
</code></pre>
<p>This will also enable the option <code>RegexOptions.IgnoreCase</code> for routes where it's regex-matching.</p>
<h2 id="not-found-404-callback-handler">Not Found (404) callback handler</h2>
<p>You can create a custom callback for when a request doesn't match any known routes.</p>
<pre><code class="lang-cs">mainRouter.NotFoundErrorHandler = () =&gt;
{
    return new HttpResponse(404)
    {
        // Since v0.14
        Content = new HtmlContent(&quot;&lt;h1&gt;Not found&lt;/h1&gt;&quot;)
        // older versions
        Content = new StringContent(&quot;&lt;h1&gt;Not found&lt;/h1&gt;&quot;, Encoding.UTF8, &quot;text/html&quot;)
    };
};
</code></pre>
<h2 id="method-not-allowed-405-callback-handler">Method not allowed (405) callback handler</h2>
<p>You can also create a custom callback for when a request matches it's path, but doens't match the method.</p>
<pre><code class="lang-cs">mainRouter.MethodNotAllowedErrorHandler = (context) =&gt;
{
    return new HttpResponse(405)
    {
        Content = new StringContent($&quot;Method not allowed for this route.&quot;)
    };
};
</code></pre>
<h2 id="internal-error-handler">Internal error handler</h2>
<p>Route callbacks can throw errors during server execution. If not handled correctly, the overall functioning of the HTTP server can be terminated. The router has a callback for when a route callback fails and prevents service interruption.</p>
<p>This method is only reacheable when <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions">ThrowExceptions</a> is set to false.</p>
<pre><code class="lang-cs">mainRouter.CallbackErrorHandler = (ex, context) =&gt;
{
    return new HttpResponse(500)
    {
        Content = new StringContent($&quot;Error: {ex.Message}&quot;)
    };
};
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/sisk-http/docs/blob/master/docs/fundamentals/routing.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
